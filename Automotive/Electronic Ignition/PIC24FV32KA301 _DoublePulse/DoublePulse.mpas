program DoublePulse;

{ Declarations section }

{$DEFINE UART}

const
  {****** MCU Setup Parameters ******}
  // Frequency the CPU is running
  OSCILLATORFREQ = 32e6;
  // How many cycles of the Oscillator for each master timer cycle
  CLOCKDIVIDER = 2;
  // Frequency of the master timer cloc
  CLOCK_FREQ = real( OSCILLATORFREQ/CLOCKDIVIDER);
  // The period of a single clock timer tick (in seconds)
  CLOCK_PERIOD = real( 1/CLOCK_FREQ);

  {****** Engine Parameters *******}
  // Engine cycles
  ENGINE_CYCLE = 4;
  // Number of Cylinders (assuming not a dual point distributor)
  CYLINDERS = 8;
  // Revolutions per Cycle
  REV_PER_CYCLE = ENGINE_CYCLE/2;

  { ****** Sofer parameters to define limits for decision logic in the program ******}
  // Smoothing RPM Filter Depth and How many valid RPM spark pulses detected in the pin change notification to
  // move on in the Stat machine before moving out of Cranking
  RPM_FILTER_LEN = 8;
  // How much of a distributor spark period to blank out before looking for the next pin change notification
  BLANK_PERCENT = 0.40;
  
  // Below this and we say we stalled and restart the Statemachine
  STALL_RPM = 50;
  STALL_DISTRIBUTOR_PERIOD = real( 60 * REV_PER_CYCLE / (STALL_RPM * CYLINDERS));
  
  // Above this and we call it a bad measurement
  MAX_RPM = 7000;
  MAX_DISTRIBUTOR_PERIOD = real( 60 * REV_PER_CYCLE / (MAX_RPM * CYLINDERS));

  INITIAL_FILTER_RPM = 100;
  INITIAL_FILTER_PERIOD = real( 60 * REV_PER_CYCLE/ (INITIAL_FILTER_RPM * CYLINDERS));
  
  // RPM where the Statemachine converts from Cranking to Running
  RUNNING_TRANSITION_RPM = 400;
  RUNNING_TRANSITION_DISTRIBUTOR_PERIOD = real( 60 * REV_PER_CYCLE / (RUNNING_TRANSITION_RPM * CYLINDERS));

  // Statemachine states
  STATE_STALLED = 0;               // Engine is not running
  STATE_DETECT_CRANKING = 1;       // Detect the owner has started to crank
  STATE_CRANKING = 2;              // Detects that the engine has started
  STATE_RUNNING = 3;               // RPM indicates we started so start averaging the pin change notification for the FiTech Output
  
  TACH_LO = 1;                     // Pin output for a Tach Lo output (common collector amplifier)
  TACH_HI = 0;                     // Pin output for a Tach Hi output (common collector amplifier)

  COILNEG = B0;    // Bit 0        // The Pin index in the associated Port for the Coil Negative Input
  TACHOUT = B9;    // Bit 9        // The Pin index in the associated Port for the Tach Output
  
  DATA_LOG_DEPTH = 350;

type
  TFilterInfoRec = record
    // RPM Averaging array and index counter
    Distributor_Period_Filter_Array: array[RPM_FILTER_LEN] of real;
    Distributor_Period_Filter_Counter: Integer;
    Distributor_Period_Filter_Average: real;
    Distrbutor_Period_Error_Short,
    Distrbutor_Period_Error_Long: LongInt;
    DetectedFiringCount: Word;
    CurrentRPM: real;
  end;
  
  TLogger = record
    PeriodError,
    RPM,
    State,
    RealtimeRPM,
    StallIRQ,
    AvgPeriod: Boolean;
  end;
  
  TParameters = record
    BlankingPercent: real;
  end;

var
  CoilNeg_Port: Word at PORTA;
  CoilNeg_Pin: sbit at LATA0_bit;
  CoilNeg_TRIS: sbit at TRISA0_bit;

  TachPort: Word at PORTB;
  TachOut_Pin: sbit at LATB9_bit;
  TachOut_TRIS: sbit at TRISB9_bit;

  HeartBeat_Port: Word at PORTA;
  HeartBeat_Pin: sbit at LATA3_bit;
  HeartBeat_TRIS: sbit at TRISA3_bit;

  Debug_Port: Word at PORTA;
  Debug_Pin: sbit at LATA2_bit;
  Debug_TRIS: sbit at TRISA2_bit;

  State: Byte;

  Logger: TLogger;
  FilterInfo: TFilterInfoRec;
  Parameters: TParameters;

  
  DataLogArray: array[DATA_LOG_DEPTH] of real;
  DataLogIndex: Word;

{$IFDEF UART}

procedure Print(var Buffer: array[128] of char);
begin
  UART2_Write_Text(Buffer);
end;

procedure PrintLine(var Buffer: array[128] of char);
begin
  Print(Buffer);
  UART2_Write(#13);
end;

procedure PrintState;
var
  Buffer: array[6] of char;
begin
  IntToStr(State, Buffer);
  PrintLine(Buffer);
end;

procedure PrintStateChange(NewState, OldState: Word);
var
  Buffer: array[6] of char;
begin
  IntToStr(OldState, Buffer);
  Print(Buffer);
  Print('->');
  IntToStr(NewState, Buffer);
  PrintLine(Buffer);
end;

procedure PrintReal(AReal: real);
var
  Buffer: array[23] of char;
begin
  FloatToStr(AReal, Buffer);
  PrintLine(Buffer);
end;

procedure PrintRPM;
begin
  PrintReal(FilterInfo.CurrentRPM);
end;

procedure PrintAveragePeriod;
begin
  PrintReal(FilterInfo.Distributor_Period_Filter_Average);
end;

procedure PrintDistributorPeriodErrors;
var
  Buffer: array[10] of char;
begin
  LongWordToStr(FilterInfo.Distrbutor_Period_Error_Short, Buffer);
  Print('Short T: ');
  PrintLine(Buffer);
  LongWordToStr(FilterInfo.Distrbutor_Period_Error_Long, Buffer);
  Print('Long T: ');
  PrintLine(Buffer);
end;

procedure PrintHelp;
begin
  PrintLine('0 : Disables all Logging');
  PrintLine('i,I : Stall Interrupt Logging');
  PrintLine('s,S : Toggle State Logging');
  PrintLine('r,R : Toggle RPM Logging');
  PrintLine('t,T : Toggle Realtime RPM Logging (can cause interrupt timing overrun issues)');
  PrintLine('a,A : Toggle Average Period Logging');
  PrintLine('p,P : Toggle Period Error Logging');
  PrintLine('c,C : Clear Period Error Logging counters');
  PrintLine('b,B : Set Blanking Percent send as 05 (5%), 50 (50%) etc');
  PrintLine('d,D : Dump the DataLog array');
  PrintLine('l,L : Reset DataLog index for another run of data logging');
end;

{$ENDIF}

procedure InitilizeDataLog;
var
  i: Integer;
begin
  DataLogIndex := 0;
  for i := 0 to DATA_LOG_DEPTH - 1 do
    DataLogArray[i] := -1.0;
end;

procedure PrintDataLog;
var
  i: Integer;
begin
  for i := 0 to DATA_LOG_DEPTH - 1 do
    PrintReal(DataLogArray[i]);
end;

// Converts an RPM into a Period Time between each cyclinder firing in Seconds
function RPM_To_Distributor_Period(RPM: real): real;
begin
  Result := 0.0;
  if RPM > 0 then
    Result := real( 60 * REV_PER_CYCLE / (RPM * CYLINDERS ));
end;

// Converts a Period of Time between cylinder firings into RPM
function Distributor_Period_To_RPM(Distributor_Period: real): real;
begin
  Result := 0.0;
  if Distributor_Period > 0.0 then
    Result := real( 60 / Distributor_Period / CYLINDERS * REV_PER_CYCLE)
end;

// Converts a DWORD Timer Count to actual elapsed time (seconds) scaled by the Timer Divider (used 1, 8, 32, 64, etc)
function TimerCounts_To_Time(TimerCounts: DWORD; Divider: Word): real;
begin
  Result := real( TimerCounts) * CLOCK_PERIOD * real( Divider);
end;

// Converts time (seconds) to a DWORD Timer Count using the passed Timer Divider (1, 8, 32, 64, etc)
function Time_To_TimerCounts(Time: real; Divider: Word): DWORD;
begin
  Result := DWORD( Time / (CLOCK_PERIOD * real( Divider)))
end;

procedure ChangeState(NewState: Word);
begin
  if NewState <> State then
  begin
    {$IFDEF UART}
    if Logger.State then
      PrintStateChange(NewState, State);
    {$ENDIF}
    State := NewState;
  end;
end;

// Calculates the average of the items in the Distributor Period Array
function AverageDistributorPeriod: real;
var
  i: Integer;
begin
  Result := 0.0;
  for i := 0 to RPM_FILTER_LEN - 1 do
    Result := Result + FilterInfo.Distributor_Period_Filter_Array[i];
  Result := Result / RPM_FILTER_LEN
end;

function ValidPeriod(Period: real): Boolean;
begin
  // Arbitrary number though it can't be the Transition Running RPM exactly or it won't jump to the Running State
  // So limit it to 2x the Transition to Running RPM
  if State <> STATE_RUNNING then
    Result := (Period < STALL_DISTRIBUTOR_PERIOD) and (Period > (RUNNING_TRANSITION_DISTRIBUTOR_PERIOD / 2))
  else
    Result := (Period < STALL_DISTRIBUTOR_PERIOD) and (Period > MAX_DISTRIBUTOR_PERIOD)
end;

procedure UpdateDistributorArrayAndAverage(NewDistributorTime: real);
begin
  if ValidPeriod(NewDistributorTime) then
  begin
  // Insert the lastest item in the array
    FilterInfo.Distributor_Period_Filter_Array[FilterInfo.Distributor_Period_Filter_Counter] := NewDistributorTime;
    Inc(FilterInfo.Distributor_Period_Filter_Counter);
    // Update the array counter
    if FilterInfo.Distributor_Period_Filter_Counter >= RPM_FILTER_LEN then
      FilterInfo.Distributor_Period_Filter_Counter := 0;
    FilterInfo.Distributor_Period_Filter_Average := AverageDistributorPeriod;
    FilterInfo.CurrentRPM := 0.0;
  end
end;

// Sends the delayed blanking pulse to the FiTech and stalls the CN Interrupt for the blanking
procedure TriggerOutput_With_Wait(BlankingTime: real);
begin
  TachOut_Pin := TACH_Hi;
  Delay_Cyc_Long( Time_To_TimerCounts(BlankingTime * Parameters.BlankingPercent, 1));  // Just a bit more than 15 degrees dwell (out of 45
  TachOut_Pin := TACH_LO;
end;

procedure InitializeFilterInfo;
var
  i: Integer;
begin
  FilterInfo.Distributor_Period_Filter_Counter := 0;
  FilterInfo.DetectedFiringCount := 0;
  FilterInfo.Distributor_Period_Filter_Average := INITIAL_FILTER_PERIOD;
  for i := 0 to RPM_FILTER_LEN - 1 do
    FilterInfo.Distributor_Period_Filter_Array[i] := INITIAL_FILTER_PERIOD;
  FilterInfo.Distributor_Period_Filter_Counter := 0;
end;

procedure InitializeLogger;
begin
  Logger.PeriodError := False;
  Logger.RPM := False;
  Logger.State := False;
  Logger.RealtimeRPM := False;
  Logger.StallIRQ := False;
  Logger.AvgPeriod := False;
end;

procedure InitializeStalledState;
var
  i: Integer;
begin
  // Shut off the Cranking Trigger Timer if we stalled
  TachOut_Pin := TACH_LO;
  InitializeFilterInfo
end;

procedure interrupt_TMR3_RPM_Measurment_And_Stall_Timer(); iv IVT_ADDR_T3INTERRUPT;
begin
  // Reset the RPM/Stall Timer; Keep looking for stalls as that is the only way to enter this
  TMR3HLD := $0000;
  TMR2 := $0000;
  InitializeStalledState;
  ChangeState(STATE_STALLED);
  {$IFDEF UART}if Logger.StallIRQ then PrintLine('Stall Detected - IRQ');{$ENDIF}
  T3IF_bit := 0;                 // Reset Interrupt Flag
end;

procedure interrupt_PinChangeNotification(); iv IVT_ADDR_CNINTERRUPT;
var
  PortCopy: Word;
  DistributorPeriod: real;
  DistributorPeriodTimerCount: DWord;
begin
  PortCopy := CoilNeg_Port;    // Clear all changes
  // Detect rising edges only
  if PortCopy.COILNEG = 1 then
  begin
    // Capture RPM/Stall Timer contents
    LoWord(DistributorPeriodTimerCount) := TMR2;
    HiWord(DistributorPeriodTimerCount) := TMR3HLD;
    // Reset the RPM/Stall Timer
    TMR3HLD := $0000;
    TMR2 := $0000;
    // Makes sure it can't jump to the stall interrupt
    T3IF_bit := 0;

    DistributorPeriod := TimerCounts_To_Time(DistributorPeriodTimerCount, 1);
    FilterInfo.CurrentRPM := Distributor_Period_To_RPM(DistributorPeriod);

    if DataLogIndex < DATA_LOG_DEPTH then
    begin
      DataLogArray[DataLogIndex] := FilterInfo.CurrentRPM;
      Inc(DataLogIndex);
    end;
    
    {$IFDEF UART}if Logger.RealtimeRPM then PrintRPM;{$ENDIF}

    case State of
      STATE_STALLED :
        begin
          InitializeStalledState;
          ChangeState(STATE_DETECT_CRANKING);
        end;
      STATE_DETECT_CRANKING :
        begin
          Inc(FilterInfo.DetectedFiringCount);
          
          // Assmme an RPM for the first few cranks, Average is preloaded with an assumed cranking RPM
          Delay_Cyc_Long( Time_To_TimerCounts(FilterInfo.Distributor_Period_Filter_Average * Parameters.BlankingPercent, 1));
          
          // Just get a few stable pulses before moving on and starting to average
          if FilterInfo.DetectedFiringCount > 1 then
            ChangeState(STATE_CRANKING);
        end;
      STATE_CRANKING :
        begin
          // Try to update the average while cranking
          UpdateDistributorArrayAndAverage(DistributorPeriod);
          TriggerOutput_With_Wait(FilterInfo.Distributor_Period_Filter_Average);
          
          // When the average looks like it is running move on to the next state
          if FilterInfo.Distributor_Period_Filter_Average < RUNNING_TRANSITION_DISTRIBUTOR_PERIOD then
            ChangeState(STATE_RUNNING);
        end;
      STATE_RUNNING :
        begin
          UpdateDistributorArrayAndAverage(DistributorPeriod);
          TriggerOutput_With_Wait(FilterInfo.Distributor_Period_Filter_Average);
      end else
        ChangeState(STATE_STALLED); // State is messed up, start over
    end;    // Case
  end;
  // Some free debounce guarding by putting this at the end
  CNIF_bit := 0;
end;


var
  StrBuffer: array[128] of Char;
  DelimiterStr: string[1];
  TempR: real;
  DebugPeriod, DebugBlankPeriod: real;
//  i: Integer;
begin
  { Main program }
  ANSA := 0;        // Make them all Digital
  ANSB := 0;

  State := STATE_STALLED;
  InitializeLogger;
  InitilizeDataLog;
  InitializeFilterInfo;
  
  Parameters.BlankingPercent := BLANK_PERCENT;
  
  TachOut_Pin := TACH_LO;   // Set it low
  HeartBeat_Pin := 0;
  Debug_Pin := 0;

  CoilNeg_TRIS := 1;   // Input
  TachOut_TRIS := 0;   // Tach Output
  HeartBeat_TRIS := 0; // Output
  Debug_TRIS := 0;

  // Clock Setup
  CLKDIV := 0;                      // Set both dividers to 1:1 and don't use the DOZE to reset dividers (power saving feature)
  
  // RPM Timer
  // Lower Timer controls the setup Setup
  TON_T2CON_bit := 0;                // OFF
  TON_T3CON_bit := 0;                // OFF
  T32_T2CON_bit := 1;                // 32 Bit mode
  TCS_T2CON_bit := 0;                // Internal source
  TGATE_T2CON_bit := 0;              // Disabled Gated Timer Mode
  TCKPS_0_T2CON_bit := 0;            // 00 = 1; 01 = 8; 10 = 64; 11 = 256
  TCKPS_1_T2CON_bit := 0;
  PR2 := LoWord( DWORD(STALL_DISTRIBUTOR_PERIOD/CLOCK_PERIOD));
  PR3 := HiWord( DWORD(STALL_DISTRIBUTOR_PERIOD/CLOCK_PERIOD));
  TMR3HLD := 0;
  TMR2 := 0;
  // Upper Timer fires the interrupts
  T3IP_0_bit := 1;                   // priority
  T3IP_1_bit := 0;
  T3IP_2_bit := 0;
  T3IF_bit := 0;                     // clear T1IF
  T3IE_bit := 1;                     // enable Timer1 interrupts
  // Lower Timer controls the setup Setup
  TON_T2CON_bit := 1;                // ON

  {$IFDEF UART}
  UART2_Init(115200);
  Delay_ms(100);
  
  Print('STALL_DISTRIBUTOR_PERIOD=');
  FloatToStr(STALL_DISTRIBUTOR_PERIOD, StrBuffer);
  Print(StrBuffer);

  Print('DWORD(STALL_DISTRIBUTOR_PERIOD/CLOCK_PERIOD)=');
  LongWordToStr(DWORD(STALL_DISTRIBUTOR_PERIOD/CLOCK_PERIOD), StrBuffer);
  Print(StrBuffer);

  Print('PRL=');
  WordToStr(TMR2, StrBuffer);
  Print(StrBuffer);
  Print('  PRH=');
  WordToStr(TMR3HLD, StrBuffer);
  PrintLine(StrBuffer);

  PrintHelp;
  {$ENDIF}

  // ALWAYS DO THIS LAST
  // Pin change Notification
  CN2IE_bit := 1;  // Pin Change Notification Interrupt on RA0
  CNIP_0_bit := 1;  // Interrupt priority = 7
  CNIP_1_bit := 1;
  CNIP_2_bit := 1;
  CNIF_bit := 0;    // Clear Pin Change Interrupt flag
  CNIE_bit := 1;    // Enable all Pin Change Interrupts


  while true do
  begin
    Delay_ms(100);
    {$IFDEF UART}
    if UART2_Data_Ready then
    begin
      case UART2_Read of
        '0' :
          begin
            InitializeLogger;
          end;
        's', 'S' :
          begin
            Logger.State := not Logger.State;
            if Logger.State then PrintLine('State Logging ON') else
              PrintLine('State Logging OFF');
          end;
        'c', 'C' : 
          begin
            FilterInfo.Distrbutor_Period_Error_Short := 0;
            FilterInfo.Distrbutor_Period_Error_Long := 0;
            PrintLine('Counts Cleared');
          end;
        'b', 'B' :
          begin
            DelimiterStr[0] := #13;
            DelimiterStr[1] := $00;
            PrintLine('Reading Blanking Value');
            UART2_Read_Text(StrBuffer, DelimiterStr, 2);
            UART2_Write_Text('Read: ');
            PrintLine(StrBuffer);
            TempR := real( StrToInt(StrBuffer)) * 0.01;
            if TempR > 0.05 then
            begin
              Parameters.BlankingPercent := TempR;  // This could cause a burp if the interrupt uses it
              UART2_Write_Text('New Blanking Value ');
              FloatToStr(Parameters.BlankingPercent * 100, StrBuffer);
              UART2_Write_Text(StrBuffer);
              PrintLine('%');
            end else
            begin
              PrintLine('Value Read was too small must be greater than 5%');
              FloatToStr(Parameters.BlankingPercent * 100, StrBuffer);
              UART2_Write_Text(StrBuffer);
              PrintLine('%');
            end;
          end;
        'p', 'P' :
          begin
            Logger.PeriodError := not Logger.PeriodError;
            if Logger.PeriodError then PrintLine('Period Error Logging ON') else
              PrintLine('Period Error Logging OFF');
          end;
        'r', 'R' :
          begin
            Logger.RPM := not Logger.RPM;
            if Logger.RPM then PrintLine('RPM Logging ON') else
              PrintLine('RPM Logging OFF');
          end;
        't', 'T' :
          begin
            Logger.RealtimeRPM := not Logger.RealtimeRPM;
            if Logger.RealtimeRPM then PrintLine('RealTime RPM Logging ON') else
              PrintLine('RealTime RPM Logging OFF');
          end;
        'i', 'I' :
          begin
            Logger.StallIRQ := not Logger.StallIRQ;
            if Logger.StallIRQ then PrintLine('RealTime RPM Logging ON') else
              PrintLine('RealTime RPM Logging OFF');
          end;
          'a', 'A' :
          begin
            Logger.AvgPeriod := not Logger.AvgPeriod;
            if Logger.AvgPeriod then PrintLine('Avg T Logging ON') else
              PrintLine('Avg T Logging OFF');
          end;
          'l', 'L' :
          begin
            InitilizeDataLog;
            PrintLine('DataLog Index reset');
          end;
          'd', 'D' :
          begin
            PrintDataLog;
          end;
        '?', 'h', 'H' : 
          begin
            PrintHelp;
          end;
      end;
    end;
    
    If Logger.RPM then
      PrintRPM;
    if Logger.AvgPeriod then
      PrintAveragePeriod;
    if Logger.State then
      PrintState;
    if Logger.PeriodError then
      PrintDistributorPeriodErrors;
    {$ENDIF}
    // Waitin for Pin Change Interrupt
    HeartBeat_Pin := not HeartBeat_Pin;
  end;
end.

 {
  // Fixed RPM to send to the FiTech during cranking
  FIXED_CRANKING_RPM = 100;
  FIXED_CRANKING_DISTRIBUTOR_PERIOD = real( 60 * REV_PER_CYCLE/ (FIXED_CRANKING_RPM * CYLINDERS));
}

{
procedure interrupt_TMR5_Cranking_FiTech_Triggger_Timer(); iv IVT_ADDR_T5INTERRUPT;
begin
  // Keep firing the FiTech at a predefined rate during cranking
  TachOut_Pin := not(TachOut_Pin);
  T5IF_bit := 0;                 // Reset Interrupt Flag
end;
}

 {
  // Fixed Cranking RPM Timer (fires at 1/2 the period)
  // Lower Timer controls the setup Setup
  TON_T4CON_bit := 0;                // OFF
  TON_T5CON_bit := 0;                // OFF
  T32_T4CON_bit := 1;                // 32 Bit mode
  TCS_T4CON_bit := 0;                // Internal source
  TGATE_T4CON_bit := 0;              // Disabled Gated Timer Mode
  TCKPS_0_T4CON_bit := 0;            // 00 = 1; 01 = 8; 10 = 64; 11 = 256
  TCKPS_1_T4CON_bit := 0;
  PR4 := LoWord( DWORD(FIXED_CRANKING_DISTRIBUTOR_PERIOD/CLOCK_PERIOD/2));
  PR5 := HiWord( DWORD(FIXED_CRANKING_DISTRIBUTOR_PERIOD/CLOCK_PERIOD/2));
  TMR5HLD := 0;
  TMR4 := 0;
  // Upper Timer fires the interrupts
  T5IP_0_bit := 1;                   // priority
  T5IP_1_bit := 0;
  T5IP_2_bit := 0;
  T5IF_bit := 0;                     // clear T1IF
  T5IE_bit := 1;                     // enable Timer1 interrupts
}