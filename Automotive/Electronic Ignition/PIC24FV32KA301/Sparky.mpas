program Sparky;

{ Declarations section }

{$DEFINE DEBUG_UART}

const
  // Engine Parameters
  ENGINE_CYCLE = 4;
  CYLINDERS = 8;
  STALL_RPM = 50;

  // Coil Parameters
  COIL_MAG_L                     = 0.008;      // Henries
  COIL_R                         = 1.5;        // Ohms
  COIL_DESIRED_I                 = 4.5;        // Amps
  COIL_PRIMIARY_V                = 14;         // Volts
  COIL_CHARGE_TIME_MULTIPLIER    = 5;          // To deal with accell and decell and predicting when the next pulse will come need to extent the pulse to ensure no dropouts
  RPM_LIMIT                      = 7000;       // Shuts off the IGBT above this RPM
  RPM_STALL                      = 70;         // Shuts off the IGBT below the RPM
  FIRING_CRANKSHAFT_DEGREES      = 15;         // Number of Degrees to wait for the cycle to finish firing
  DWELL_CRANKSHAFT_DEGREES       = 30;         // Number of Degrees the cycle is not firing

  // MCU Setup Parameters
  OSCILLATORFREQ = 32e6;
  CLOCKDIVIDER = 2;
  TIMER_DIVIDER = 256;

  // MCU Clock Calculated Parameters
  CLOCK_FREQ = real( OSCILLATORFREQ/CLOCKDIVIDER);
  CLOCK_PERIOD = real( 1/CLOCK_FREQ);

  // Coil Calculated Parameters
  COIL_CHARGE_TIME = COIL_DESIRED_I * COIL_MAG_L/COIL_PRIMIARY_V;
  
  // Dwell Start Timer Calculated Parameters
  MAX_DWELL_PERIOD = COIL_CHARGE_TIME * COIL_CHARGE_TIME_MULTIPLIER * 2;      // Never have the IGBT on for more than 2x of the Charge time
  MAX_DWELL_COUNT = dWord(MAX_DWELL_PERIOD/CLOCK_PERIOD);

  // Revolutions per Cycle
  REV_PER_CYCLE = ENGINE_CYCLE/2;

  // DWELL numbers
  FIRING_DISTRIBUTOR_DEGREES = FIRING_CRANKSHAFT_DEGREES * REV_PER_CYCLE;
  DWELL_DISTRIBUTOR_DEGREES = DWELL_CRANKSHAFT_DEGREES * REV_PER_CYCLE;
  
  // Advance numbers
  NUMBER_OF_ADVANCE_POINTS = 4;

var
  RPM: real;
  Dwell: dword;
  Max_Dwell_Exceeded: Boolean;
  
  TimingCurveRPM    : array[NUMBER_OF_ADVANCE_POINTS] of real;
  TimingCurveDegrees: array[NUMBER_OF_ADVANCE_POINTS] of real;
  LastTimingAdvanceDegrees: real;

 // IGBT_Pin: sbit at LATA1_bit;
 // IGBT_TRIS: sbit at TRISA1_bit;


procedure interrupt_Timer3_RPM_Measurement(); iv IVT_ADDR_T3INTERRUPT;
begin
  T3IF_bit := 0;                 // Reset Interrupt Flag
  LATA0_bit := not LATA0_bit;
  TON_T2CON_bit := 0;            // Turn this timer off again.
end;

procedure interrupt_Timer5_Dwell_Delay(); iv IVT_ADDR_T5INTERRUPT;
begin 
  // The time to wait until the IGBT is turned on just before the next distributor trigger
  // was loaded in the last distributor trigger and we should not turn on the IGBT
  
  // Turn on the IGBT, the next Pin Change will turn it off, unless we detect that the
  // IGBT has been on way to long then turn it back off and reset for a new try
  if Max_Dwell_Exceeded then
    LATA1_bit := 0
  else
    LATA1_bit := 1;

  // Load up the Dwell timer with a time that the longest the IGBT should ever be on and start it off
  // This is a safety trap to ensure we don't stick the IGBT on
  TON_T4CON_bit := 0;                // OFF
  PR4 := LoWord(MAX_DWELL_COUNT);
  PR5 := HiWord(MAX_DWELL_COUNT);
  TMR5HLD := $0000;
  TMR4 := $0000;
  
  TON_T4CON_bit := 1;                // ON

  Max_Dwell_Exceeded := True;   // Pin Change will clear this or if this interrupt is entered before that something is wrong and we will shut off the IGBT

  T5IF_bit := 0;  // Reset the interrupt Flag
end;

procedure interrupt_Timer1(); iv IVT_ADDR_T1INTERRUPT;
begin
  T1IF_bit := 0;             // clear T1IF
  LATB12_bit := not LATB12_bit;
end;

procedure interrupt_PinChangeNotification(); iv IVT_ADDR_CNINTERRUPT;
var
  PortCopy: Word;
  TimerCount, Dwell_Delay_Count, TimingAdvanceCount: dword;
  Distributor_Period, Dwell_Delay_Period, Dynamic_Dwell_Delay_Period, SecondsPerDegree, TimingAdvanceDegrees, Slope: real;
  i, TimingCurveIndex: Integer;
  
  s: string[128];
begin
  PortCopy := PORTB;    // Clear all changes

  // Detect rising edges only
  if PortCopy.B9 = 1 then
  begin
    LATB8_bit := 1;

    // Shutoff IGBT
    LATA1_bit := 0;

    // Capture it contents
    LoWord(TimerCount) := TMR2;
    HiWord(TimerCount) := TMR3HLD;
    // Reset the RPM Timer
    TMR3HLD := $0000;
    TMR2 := $0000;
    
    Distributor_Period := real( TimerCount) * CLOCK_PERIOD;

    RPM := 0.0;
    if Distributor_Period > 0.0 then
      RPM := 60/Distributor_Period/CYLINDERS*REV_PER_CYCLE;

    if (RPM < RPM_STALL) or (RPM > RPM_LIMIT) then
      RPM := 0.0;

    if RPM > 0.0 then
    begin
    
      LATB13_bit := 1;
      
 
      TimingCurveIndex := NUMBER_OF_ADVANCE_POINTS;  // Assume above highest RPM; Note this is OUTSIDE of the range for the array
      i := 1;
      while i < NUMBER_OF_ADVANCE_POINTS do
      begin
        if RPM < TimingCurveRPM[i] then
        begin
          TimingCurveIndex := i;
          Break;
        end;
        Inc(i);
      end;

      // If we are below the max advance need to calculate it
      if TimingCurveIndex < NUMBER_OF_ADVANCE_POINTS then
      begin
        // Guard against a zero denominator.  If this happens the array has of the same RPM in 2 positions which is an error
        if TimingCurveRPM[TimingCurveIndex] - TimingCurveRPM[TimingCurveIndex-1] <> 0 then
        begin
          Slope := (TimingCurveDegrees[TimingCurveIndex] - TimingCurveDegrees[TimingCurveIndex-1])/(TimingCurveRPM[TimingCurveIndex] - TimingCurveRPM[TimingCurveIndex-1]);
          TimingAdvanceDegrees := -(Slope * (TimingCurveRPM[TimingCurveIndex-1] - RPM) - TimingCurveRPM[TimingCurveIndex-1]);  // y1 = -(m(x-x1)-y)
        end else
          TimingAdvanceDegrees := TimingCurveDegrees[TimingCurveIndex];
      end else
        TimingAdvanceDegrees := TimingCurveDegrees[NUMBER_OF_ADVANCE_POINTS-1];
        
      {$IFDEF DEBUG_UART}
      if TimingAdvanceDegrees <> LastTimingAdvanceDegrees then
      begin
        FloatToStr(TimingAdvanceDegrees, s);
        UART2_Write_Text(s);
      end;
      {$ENDIF}
      LastTimingAdvanceDegrees := TimingAdvanceDegrees;

      LATB13_bit := 0;
    
    
                                                               // RevolutionsPerSec := RPM/60;
                                                               // DegreesPerSecond := 360*RevolutionsPerSec;  360_Degrees/Revolution  *  Revolution/Sec = Degrees/Sec
      SecondsPerDegree := 1/(6*RPM);                           // 1/DegreesPerSecond  = 1/(360*RevolutionsPerSec) = 1/(360*RPM/60) = 1/(360/60*RPM) = 1/(6*RPM)
    
      // How far to shift the trigger for advance
      TimingAdvanceCount := DWORD( TimingAdvanceDegrees*SecondsPerDegree/CLOCK_PERIOD);
  
  
      // Calculate when to turn the IGBT on to start charging
      
      // Dynamically change the amount of time we let the cyclinder combustion to complete
      // Note there is NO assumption on when the next trigger will come other than
      // using the last period to calcuate the RPM to get the Seconds Per Degree
      Dwell_Delay_Period := (FIRING_DISTRIBUTOR_DEGREES * SecondsPerDegree) { - Time_it_took_to_get_from_the_entry_of_this_function_to_here:};  // TODO
      
      if Distributor_Period - Dwell_Delay_Period > COIL_CHARGE_TIME then
      begin
        // This assumes a fixed RPM and Distributor_Period.  If the rate of change is fast enough
        // This will fail spectacularly with either the trigger comes before the IGBT is turned on
        // (acceleration) or the IGBT comes on way too early and the trigger is delayed (deceleration)
        // The charge time is way to much do something to shorten it to a reasonable value.
        Dynamic_Dwell_Delay_Period := Distributor_Period - (COIL_CHARGE_TIME_MULTIPLIER * COIL_CHARGE_TIME);
        if Dynamic_Dwell_Delay_Period > Dwell_Delay_Period then
          Dwell_Delay_Period := Dynamic_Dwell_Delay_Period;
      end;
      
      // Convert the Period (seconds) into counts based on the clock frequency)
      Dwell_Delay_Count :=  DWORD( Dwell_Delay_Period/(CLOCK_PERIOD));

      // Load up the Dwell timer and start it off
      Max_Dwell_Exceeded := False;
      TON_T4CON_bit := 0;                // OFF
      PR4 := LoWord(Dwell_Delay_Count);
      PR5 := HiWord(Dwell_Delay_Count);
      TMR5HLD := $0000;
      TMR4 := $0000;
      TON_T4CON_bit := 1;                // ON
    end;

    LATB8_bit := 0;
  end;

  // Some free debounce guarding by putting this many micro seconds past entry
  CNIF_bit := 0;
end;

var
  i: Integer;

begin
  { Main program }
  ANSA := 0;        // Make them all Digital
  ANSB := 0;
  LATA1_bit := 0; // Keep the IGBT off

  TRISA0_bit := 0; // Output CPP1 timer Interrupt
  TRISA1_bit := 0; // Output CPP2 timer Interrupt - IGBT Gate [BLUE]
  TRISB0_bit := 0; // Output for UART 2 TX
  TRISB1_bit := 1; // Input for UART 2 RX
  TRISB9_bit := 1; // Input (redundant but makes it clear)   [BROWN]
  TRISB8_bit := 0; // CAM Sensor                             [RED]
  TRISB12_bit := 0; // Output  Timer 1 Trigger               [ORANGE]
  TRISB13_bit := 0; // Output  GP Debug
  TRISB14_bit := 0; // Output  Heartbeat

  // Clock Setup
  CLKDIV := 0;                      // Set both dividers to 1:1 and don't use the DOZE to reset dividers (power saving feature)


  // Initializze Variables
  RPM := 0.0;
  Max_Dwell_Exceeded := True;               // Start Safe
  LastTimingAdvanceDegrees := 0.0;

  // Build my Advance table
  TimingCurveRPM[0] := 0.0;     TimingCurveDegrees[0] := 0.0;
  TimingCurveRPM[1] := 1200.0;  TimingCurveDegrees[1] := 6.0;
  TimingCurveRPM[2] := 2000.0;  TimingCurveDegrees[2] := 10.0;
  TimingCurveRPM[3] := 2500.0;  TimingCurveDegrees[3] := 12.0;

  // Pin change Notification
  CN21IE_bit := 1;  // Pin Change Notification Interrupt on B9
  CNIP_0_bit := 1;  // Interrupt priority = 7
  CNIP_1_bit := 1;
  CNIP_2_bit := 1;
  CNIF_bit := 0;    // Clear Pin Change Interrupt flag
  CNIE_bit := 1;    // Enable all Pin Change Interrupts


  // Timer Setup
  TMR1 := 0;
  TON_T1CON_bit := 0;             // OFF
  TCKPS_0_bit := 0;            // 00 = 1; 01 = 8; 10 = 64; 11 = 256
  TCKPS_1_bit := 0;
  IPC0 := IPC0 or 0x1000;      // interrupt priority level = 1
  T1IF_bit := 0;               // clear T1IF
  T1IE_bit := 1;               // enable Timer1 interrupts
  TON_T1CON_bit := 1;                // ON
  
  // Lower Timer controls the setup Setup
  TON_T2CON_bit := 0;                // OFF
  TON_T3CON_bit := 0;                // OFF
  T32_T2CON_bit := 1;                // 32 Bit mode
  TCS_T2CON_bit := 0;                // Internal source
  TGATE_T2CON_bit := 0;              // Disabled Gated Timer Mode
  TCKPS_0_T2CON_bit := 0;            // 00 = 1; 01 = 8; 10 = 64; 11 = 256
  TCKPS_1_T2CON_bit := 0;
  IPC2 := IPC2 or 0x1000;            // interrupt priority level = 1
  PR2 := $FFFF;
  PR3 := $FFFF;
  TMR3HLD := 0;
  TMR2 := 0;
  // Upper Timer fires the interrupts
  T3IP_0_bit := 1;                   // priority
  T3IP_1_bit := 0;
  T3IP_2_bit := 0;
  T3IF_bit := 0;                     // clear T1IF
  T3IE_bit := 1;                     // enable Timer1 interrupts
  // Lower Timer controls the setup Setup
  TON_T2CON_bit := 1;                // ON
  
  // Lower Timer controls the setup Setup
  TON_T4CON_bit := 0;                // OFF
  TON_T5CON_bit := 0;                // OFF
  T32_T4CON_bit := 1;                // 32 Bit mode
  TCS_T4CON_bit := 0;                // Internal source
  TGATE_T4CON_bit := 0;              // Disabled Gated Timer Mode
  TCKPS_0_T4CON_bit := 0;            // 00 = 1; 01 = 8; 10 = 64; 11 = 256
  TCKPS_1_T4CON_bit := 0;
  IPC7 := IPC7 or 0x1000;            // interrupt priority level = 1
  PR4 := LoWord(MAX_DWELL_COUNT);
  PR5 := HiWord(MAX_DWELL_COUNT);
  TMR5HLD := 0;
  TMR4 := 0;
  // Upper Timer fires the interrupts
  T5IP_0_bit := 1;                   // priority
  T5IP_1_bit := 0;
  T5IP_2_bit := 0;
  T5IF_bit := 0;                     // clear T1IF
  T5IE_bit := 1;                     // enable Timer1 interrupts
  // Lower Timer controls the setup Setup
  TON_T4CON_bit := 1;                // ON
  
  // Setup the UART
  UART2_Init(230400);
  Delay_ms(100);
  
  while true do
  begin        // Waitin for Pin Change Interrupt
    if UART2_Data_Ready > 0 then
    begin
      UART2_Read;
    end;
    LATB14_bit := not LATB14_bit;  // Heartbeat
  end;
end.