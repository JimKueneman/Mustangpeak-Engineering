unit CanBufferOut;

uses
  HelperCAN;

procedure CanBufferOut_Initialize;
function CanBufferOut_NextEmpty: POpenLCBCanBuffer;
function CanBufferOut_NextFull(var CanBuffer: TOpenLCBCanBuffer): Boolean;

implementation

const
  CAN_OUT_BUFFER_MAX = 128;
  
type
  TCanOutBuffer = record
    Buffer: array[CAN_OUT_BUFFER_MAX] of TOpenLCBCanBuffer;
    iHead,
    iTail: integer;
    Overrun: Boolean;
  end;
  
var
  CanOut: TCanOutBuffer;

procedure CanBufferOut_Initialize;
var
  i, j: Integer;
begin
  for i := 0 to CAN_OUT_BUFFER_MAX - 1 do
  begin
    CanOut.Buffer[i].MTI := 0;
    CanOut.Buffer[i].PayLoadCount := 0;
    for j := 0 to 7 do
      CanOut.Buffer[i].Payload[j] := 0;
  end;
  CanOut.iHead := 0;
  CanOut.iTail := 0;
  CanOut.Overrun := False;
end;

function CanBufferOut_NextEmpty: POpenLCBCanBuffer;
begin
  Result := @CanOut.Buffer[CanOut.iHead];
  Inc(CanOut.iHead);
  if CanOut.iHead >= CAN_OUT_BUFFER_MAX then
    CanOut.iHead := 0;
  if CanOut.iHead = CanOut.iTail then
  begin
    Dec(CanOut.iHead);
    if CanOut.iHead < 0 then
      CanOut.iHead := CAN_OUT_BUFFER_MAX - 1;
    CanOut.Overrun := True;
    Result := nil;
  end;
end;


function CanBufferOut_NextFull(var CanBuffer: TOpenLCBCanBuffer): Boolean;
var
  i: Integer;
begin
  Result := False;
  CanBuffer.MTI := 0;  // Known value
  if CanOut.iHead <> CanOut.iTail then
  begin
    CanBuffer.MTI := CanOut.Buffer[CanOut.iTail].MTI;
    CanBuffer.PayloadCount := CanOut.Buffer[CanOut.iTail].PayloadCount;
    for i := 0 to 7 do
      CanBuffer.Payload[i] := CanOut.Buffer[CanOut.iTail].Payload[i];
    Inc(CanOut.iTail);
    if CanOut.iTail >= CAN_OUT_BUFFER_MAX then
      CanOut.iTail := 0;
    Result := True;
  end
end;

end.