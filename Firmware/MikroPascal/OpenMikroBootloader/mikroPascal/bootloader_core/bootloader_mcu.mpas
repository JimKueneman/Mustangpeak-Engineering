unit bootloader_mcu;

// Version 0.1
//
// The contents of this file are subject to the Mozilla Public License
// Version 1.1 (the "License"); you may not use this file except in compliance
// with the License. You may obtain a copy of the License at http://www.mozilla.org/MPL/
//
// Alternatively, you may redistribute this library, use and/or modify it under the terms of the
// GNU Lesser General Public License as published by the Free Software Foundation;
// either version 2.1 of the License, or (at your option) any later version.
// You may obtain a copy of the LGPL at http://www.gnu.org/copyleft/.
//
// Software distributed under the License is distributed on an "AS IS" basis,
// WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for the
// specific language governing rights and limitations under the License.
//
// The initial developer of this code is Jim Kueneman <jimkueneman@yahoo.com> and Vcc
//

{$IFDEF FPC}
{$mode objfpc}{$H+}

interface
{$ENDIF}

{$I options_user.inc}
{$I P16_Defines.inc}

uses
  {$IFDEF USER_DEBUG}bootloader_userdebug,{$ENDIF}
  bootloader_common_defines,
  bootloader_user,
  bootloader_common;
  
const
  {$IFDEF P32}
  PROGRAM_START_VECTOR_SIZE = 16;                         // A PIC32 Jump requires 4 Instruction = 16 Bytes this much match the number of bytes used in Bootloader_StartProgram_Vector for the MCU
  RESET_VECTOR_START_ADDRESS = 0xBFC00000;                // A PIC32 boots into address 0xBFC00000 when reset
  {$ENDIF}
  {$IFDEF P33}
  PROGRAM_START_VECTOR_SIZE = 4;                          // A PIC33 Jump requires 2 24Bit Instructions = 12 Bytes this much match the number of bytes used in Bootloader_StartProgram_Vector for the MCU
  RESET_VECTOR_START_ADDRESS = 0x000000;                  // A PIC33 boots into address 0x000000 when reset
  {$ENDIF}
  {$IFDEF P30}
  PROGRAM_START_VECTOR_SIZE = 4;                          // A PIC30 Jump requires 2 24Bit Instructions = 12 Bytes this much match the number of bytes used in Bootloader_StartProgram_Vector for the MCU
  RESET_VECTOR_START_ADDRESS = 0x000000;                  // A PIC33 boots into address 0x000000 when reset
  {$ENDIF}
  {$IFDEF P24}
  PROGRAM_START_VECTOR_SIZE = 4;                          // A PIC24 Jump requires 2 24Bit Instructions = 12 Bytes this much match the number of bytes used in Bootloader_StartProgram_Vector for the MCU
  RESET_VECTOR_START_ADDRESS = 0x000000;                  // A PIC33 boots into address 0x000000 when reset
  {$ENDIF}
  {$IFDEF P18}

  {$ENDIF}
  {$IFDEF P16}
  PROGRAM_START_VECTOR_SIZE = 2;                          // A PIC16 Jump requires 1 16 Bit Instructions =  2 Bytes this much match the number of bytes used in Bootloader_StartProgram_Vector for the MCU
  RESET_VECTOR_START_ADDRESS = 0x000000;                  // A PIC16 boots into address 0x000000 when reset
  {$ENDIF}
  
procedure Bootloader_Mcu_Initialization;
procedure Bootloader_Mcu_EraseFlash(var Address: DWord);
procedure Bootloader_Mcu_WriteFlash(var Address: DWord; ByteCount: DWord; DataPtr: PByte);
procedure BootFlash_ResetVector;
procedure Bootloader_StartProgram_Vector;

implementation

type
  TWriteByteDataArray = array[USER_BOOTLOADER_WRITE_BLOCK] of byte;
  PWriteByteDataArray = ^TWriteByteDataArray;
  TWriteWordDataArray = array[USER_BOOTLOADER_WRITE_BLOCK div 2] of Word;
  PWriteWordDataArray = ^TWriteWordDataArray;
  TWriteDWordDataArray = array[USER_BOOTLOADER_WRITE_BLOCK div 4] of DWord;
  PWriteDWordDataArray = ^TWriteDWordDataArray;

procedure Bootloader_Mcu_Initialization;
begin
  {$IFDEF P32}
  {$ENDIF}
  {$IFDEF PIC33}

  {$ENDIF}
  {$IFDEF PIC30}

  {$ENDIF}
  {$IFDEF PIC24}

  {$ENDIF}
  {$IFDEF PIC18}

  {$ENDIF}
  {$IFDEF PIC16}

  {$ENDIF}
end;

procedure Bootloader_StartProgram_Vector;
// As a function this will generate code for the return (dsPIC33 for example :RCALL        _Bootloader_StartProgram_Vector}
// This autogenerated code will get overwritten by the bootloader as a jump to the application
// start address.  The nops reserve instruction space so that instructions specific to load the address and jump to can be
// created and replace these nops (and autogenerated code)
begin
  // nops to accomodate MCU reset vector size.
  asm nop end;
  {$IFDEF P32}
  asm nop end;
  {$ENDIF}
end;

procedure BootFlash_ResetVector;
begin
  {$IFDEF P32}
    // When a program is bootloaded its memory image will be altered and this jump
    // will be replaced with this jump before it is written to the MCU
    R30 := USER_BOOTLOADER_ADDRESS; // Load R30 with bootloader main address.
    asm
      JR R30                 // Perform indirect jump to bootloader application,
      NOP                    // thus changing the kseg as well.
    end;
  {$ENDIF}
  
  // dsPIC33, dsPIC30, PIC24, PIC18, PIC16 all read the jump instructions to the main
  // program from the $000000 address of the hex file then replace those instructions
  // with jumps to the bootloader.  The inital bootloader image will automatically create
  // the correct jump from the Reset Vector to the bootloader start.  The MIPS processor
  // complicates this with its BootFlash, interrupt vectors and exceptions vectors so
  // in that MCU something special needed to be done.
end;

procedure Bootloader_Mcu_EraseFlash(var Address: DWord);
{$IFDEF P30}
var
  i: Integer;
  TempAddress: DWord;
  Temp: array[USER_BOOTLOADER_ERASE_BLOCK] of Byte;
{$ENDIF}
begin
  {$IFDEF USER_DEBUG}LongWordToHex(Address, s1);SendDebugStr('Erase Address Before: 0x' + s1);LongWordToStr(USER_BOOTLOADER_ERASE_BLOCK, s1);SendDebugStr('Erase Blocksize: ' + s1);{$ENDIF}
  {$IFDEF P32}
    Flash_Erase_Page(Address);
    Address := Address + USER_BOOTLOADER_ERASE_BLOCK;                           // 4 Bytes per instruction, 4 Addresses per instruction
  {$ENDIF}
  {$IFDEF P33}
    FLASH_Erase(Address);
    Address := Address + (USER_BOOTLOADER_ERASE_BLOCK div 3 * 2);               // 3 Bytes per instruction, 2 Addresses per instruction
  {$ENDIF}
  {$IFDEF P24}
    FLASH_Erase(Address);
    Address := Address + (USER_BOOTLOADER_ERASE_BLOCK div 3 * 2);               // 3 Bytes per instruction, 2 Addresses per instruction
  {$ENDIF}
  {$IFDEF P30}
    FLASH_Write_Compact(Address, @Temp, USER_BOOTLOADER_ERASE_BLOCK);           // Need to force the Erase to actually do something by writing first
    FLASH_Erase32(Address);                                                     // Now the Erase will actually do something
    Address := Address + (USER_BOOTLOADER_ERASE_BLOCK div 3 * 2);               // 3 Bytes per instruction, 2 Addresses per instruction
  {$ENDIF}
  {$IFDEF P18}{$ENDIF}
  {$IFDEF P16}
    {$IFDEF P16_SUPPORTS_ERASE}FLASH_Erase(Address);{$ENDIF}
    Address := Address + (USER_BOOTLOADER_ERASE_BLOCK div 2)                    // 1 Address per 2 Bytes
  {$ENDIF}
  {$IFDEF USER_DEBUG}LongWordToHex(Address, s1);SendDebugStr('Erase Address After: 0x' + s1);{$ENDIF}
end;

procedure Bootloader_Mcu_WriteFlash(var Address: DWord; ByteCount: DWord; DataPtr: PByte);
var
  i: DWord;
  DoubleWordArray: array[2] of DWord;
begin
  {$IFDEF USER_DEBUG}LongWordToHex(Address, s1); SendDebugStr('FlashWrite Address: 0x' + s1);LongWordToStr(ByteCount, s1); SendDebugStr(', ' + s1 + ' bytes ');LongWordToHex(DataPtr, s1); SendDebugStr('Data Address: 0x' + s1);SendDebugStr('[');for i := 0 to 11 do begin ByteToHex(PWriteByteDataArray( DataPtr)^[i], s1);SendDebugStr('0x' + s1);end;SendDebugStr(']');{$ENDIF}
  i := 0;
  while i < ByteCount do                                                      // PIC33 192 Bytes per Instruction
  begin
    {$IFDEF USER_DEBUG}LongWordToStr(i, s1);SendDebugStr('ByteStart: ' + s1);{$ENDIF}
    {$IFDEF P32}
      // This can only write 1 Instruction at a time so fixed values are used.
      // The MCU may require a larger write number than 1 in order to actually
      // write all the latches.  This is handled by setting USER_BOOTLOADER_WRITE_BLOCK to
      // that value and the loop calls this multiple times
      Flash_Write_Word(Address, PDWord( DataPtr)^);
      Address := Address + 4;                                                   // 1 address per 4 bytes
      DataPtr := DataPtr + 4;                                                   // 1 instruction per 4 bytes
      i := i + 4
    {$ENDIF}
    {$IFDEF P33}
      FLASH_Write_Compact(Address, PWriteByteDataArray( DataPtr)^);
      Address := Address + (USER_BOOTLOADER_WRITE_BLOCK div 3 * 2);
      DataPtr := DataPtr + USER_BOOTLOADER_WRITE_BLOCK;
      i := i + USER_BOOTLOADER_WRITE_BLOCK
    {$ENDIF}
    {$IFDEF P24}
      FLASH_Write_Compact(Address, PWriteByteDataArray( DataPtr)^);
      Address := Address + (USER_BOOTLOADER_WRITE_BLOCK div 3 * 2);
      DataPtr := DataPtr + USER_BOOTLOADER_WRITE_BLOCK;
      i := i + USER_BOOTLOADER_WRITE_BLOCK
    {$ENDIF}
    {$IFDEF P30}
      FLASH_Write_Compact(Address, DataPtr, USER_BOOTLOADER_WRITE_BLOCK);
      Address := Address + (USER_BOOTLOADER_WRITE_BLOCK div 3 * 2);
      DataPtr := DataPtr + USER_BOOTLOADER_WRITE_BLOCK;
      i := i + USER_BOOTLOADER_WRITE_BLOCK
    {$ENDIF}
    {$IFDEF P18}
    {$ENDIF}
    {$IFDEF P16}
      // This can only write 4 Instructions at a time so fixed values are used.
      // The MCU may require a larger write number than 4 in order to actually
      // write all the latches.  This is handled by setting USER_BOOTLOADER_WRITE_BLOCK to
      // that value and the loop calls this multiple times
      FLASH_Write(Address, PWriteWordDataArray( PByte( DataPtr))^);             // Look at the array of bytes as an array of words
      Address := Address + 4;                                                   // 1 address per 2 bytes
      DataPtr := DataPtr + 8;                                                   // FLASH_Write writes 8 bytes (4 Instructions or Words)
      i := i + 8                                                                // FLASH_Write writes 8 bytes (4 Instructions or Words)
    {$ENDIF}
  end;
  {$IFDEF USER_DEBUG}LongWordToStr(i, s1);SendDebugStr('Mcu Write End: ' + s1);{$ENDIF}
end;

end.