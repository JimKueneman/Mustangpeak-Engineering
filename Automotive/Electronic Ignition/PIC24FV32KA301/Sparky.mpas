program Sparky;

{ Declarations section }

const
  // Engine Parameters
  ENGINE_CYCLE = 4;
  CYLINDERS = 8;
  STALL_RPM = 50;

  // Coil Parameters
  COIL_MAG_L                     = 0.008;      // Henries
  COIL_R                         = 1.5;        // Ohms
  COIL_DESIRED_I                 = 4.5;        // Amps
  COIL_PRIMIARY_V                = 14;         // Volts
  CHANGE_NOTIFICATION_CALC_TIME  = 0.000300;   // The imperical calculation time before launching the Timer to start the DWELL
  RPM_LIMIT                      = 7000;       // Shuts off the IGBT above this RPM
  RPM_STALL                      = 70;         // Shuts off the IGBT below the RPM
  MAX_DWELL_PERIOD               = 0.010;      // Never have the IGBT on for more than 10ms

  // MCU Setup Parameters
  OSCILLATORFREQ = 32e6;
  CLOCKDIVIDER = 2;
  TIMER_DIVIDER = 256;

  // MCU Clock Calculated Parameters
  CLOCK_FREQ = real( OSCILLATORFREQ/CLOCKDIVIDER);
  CLOCK_PERIOD = real( 1/CLOCK_FREQ);

  // Dwell Start Timer Calculated Parameters
  MAX_DWELL_COUNT = dWord(MAX_DWELL_PERIOD/CLOCK_PERIOD);

  // Coil Calculated Parameters
  COIL_CHARGE_TIME = COIL_DESIRED_I * COIL_MAG_L/COIL_PRIMIARY_V;

  // Revolutions per Cycle
  REV_PER_CYCLE = ENGINE_CYCLE/2;



var
  RPM: real;
  CylinderFiringPeriod,
  Dwell: dword;
  Max_Dwell_Exceeded: Boolean;

 // IGBT_Pin: sbit at LATA1_bit;
 // IGBT_TRIS: sbit at TRISA1_bit;


procedure interrupt_Timer3_RPM_Measurement(); iv IVT_ADDR_T3INTERRUPT;
begin
  T3IF_bit := 0;                 // Reset Interrupt Flag
  LATA0_bit := not LATA0_bit;
  TON_T2CON_bit := 0;            // Turn this timer off again.
end;

procedure interrupt_Timer5_Dwell_Delay(); iv IVT_ADDR_T5INTERRUPT;
begin
  // The time to wait until the IGBT is turned on just before the next distributor trigger
  // was loaded in the last distributor trigger and we should not turn on the IGBT
  
  // Turn on the IGBT, the next Pin Change will turn it off, unless we detect that the
  // IGBT has been on way to long then turn it back off and reset for a new try
  if Max_Dwell_Exceeded then
    LATA1_bit := 0
  else
    LATA1_bit := 1;

  // Load up the Dwell timer with a time that the longest the IGBT should ever be on and start it off
  // This is a safety trap to ensure we don't stick the IGBT on
  TON_T4CON_bit := 0;                // OFF
  PR4 := LoWord(MAX_DWELL_COUNT);
  PR5 := HiWord(MAX_DWELL_COUNT);
  TMR5HLD := $0000;
  TMR4 := $0000;
  TON_T4CON_bit := 1;                // ON

  Max_Dwell_Exceeded := True;   // Pin Change will clear this or if this interrupt is entered before that something is wrong and we will shut off the IGBT

  T5IF_bit := 0;  // Reset the interrupt Flag
end;

procedure interrupt_Timer1(); iv IVT_ADDR_T1INTERRUPT;
begin
  T1IF_bit := 0;             // clear T1IF
  LATB12_bit := not LATB12_bit;
end;

procedure interrupt_PinChangeNotification(); iv IVT_ADDR_CNINTERRUPT;
var
  PortCopy: Word;
  LW: dword;
  TimerCount, Dwell_Delay_Count: dword;
  Distributor_Period, Dwell_Delay_Period: real;
  i: Integer;
begin
  PortCopy := PORTB;    // Clear all changes

  // Detect rising edges only
  if PortCopy.B9 = 1 then
  begin
    LATB8_bit := 1;

    // Shutoff IGBT
    LATA1_bit := 0;

    // Capture it contents
    LoWord(TimerCount) := TMR2;
    HiWord(TimerCount) := TMR3HLD;
    // Reset the RPM Timer
    TMR3HLD := $0000;
    TMR2 := $0000;

    Distributor_Period := TimerCount*CLOCK_PERIOD;

    RPM := 0.0;
    if Distributor_Period > 0.0 then
      RPM := 60/Distributor_Period/CYLINDERS*REV_PER_CYCLE;

    if (RPM < RPM_STALL) or (RPM > RPM_LIMIT) then
      RPM := 0.0;

    if RPM > 0.0 then
    begin
      // Calculate when to turn the IGBT on to start charging before the next trigger comes
      // This assumes a fixed RPM and Distributor_Period.  IF the rate of change is fast enough
      // This will fail spectacularly with either the trigger comes before the IGBT is turned on
      // (acceleration) or the IGBT comes on way too early and the trigger is delayed (deceleration)
      Dwell_Delay_Period := Distributor_Period - COIL_CHARGE_TIME - CHANGE_NOTIFICATION_CALC_TIME;
      
      // See if there is not enough time because the RPM is high, if so then just get it
      // turned on as fast as possible
      if Dwell_Delay_Period <= 0 then
        Dwell_Delay_Period := CHANGE_NOTIFICATION_CALC_TIME ;
        
      // Convert the Period (seconds) into counts based on the clock frequency)
      Dwell_Delay_Count :=  Dwell_Delay_Period/(CLOCK_PERIOD);

      // Load up the Dwell timer and start it off
      Max_Dwell_Exceeded := False;
      TON_T4CON_bit := 0;                // OFF
      PR4 := LoWord(Dwell_Delay_Count);
      PR5 := HiWord(Dwell_Delay_Count);
      TMR5HLD := $0000;
      TMR4 := $0000;
      TON_T4CON_bit := 1;                // ON
    end;

    LATB8_bit := 0;
  end;

  // Some free debounce guarding by putting this many micro seconds past entry
  CNIF_bit := 0;
end;

begin
  { Main program }
  ANSA := 0;        // Make them all Digital
  ANSB := 0;
  LATA1_bit := 0; // Keep the IGBT off

  TRISA0_bit := 0; // Output CPP1 timer Interrupt
  TRISA1_bit := 0; // Output CPP2 timer Interrupt - IGBT Gate [BLUE]
  TRISB9_bit := 1; // Input (redundant but makes it clear)   [BROWN]
  TRISB8_bit := 0; // CAM Sensor                             [RED]
  TRISB12_bit := 0; // Output  Timer 1 Trigger               [ORANGE]
  TRISB13_bit := 0; // Output  GP Debug
  TRISB14_bit := 0; // Output  Heartbeat

  TRISB7_bit := 0;

  // Clock Setup
  CLKDIV := 0;                      // Set both dividers to 1:1 and don't use the DOZE to reset dividers (power saving feature)



  // Pin change Notification
  CN21IE_bit := 1;  // Pin Change Notification Interrupt on B9
  CNIP_0_bit := 1;  // Interrupt priority = 7
  CNIP_1_bit := 1;
  CNIP_2_bit := 1;
  CNIF_bit := 0;    // Clear Pin Change Interrupt flag
  CNIE_bit := 1;    // Enable all Pin Change Interrupts


  // Timer Setup
  TMR1 := 0;
  TON_T1CON_bit := 0;             // OFF
  TCKPS_0_bit := 1;            // 00 = 1; 01 = 8; 10 = 64; 11 = 256
  TCKPS_1_bit := 0;
  IPC0 := IPC0 or 0x1000;      // interrupt priority level = 1
  T1IF_bit := 0;               // clear T1IF
  T1IE_bit := 1;               // enable Timer1 interrupts
  TON_T1CON_bit := 1;                // ON
  
  // Lower Timer controls the setup Setup
  T32_T2CON_bit := 1;                // 32 Bit mode
  TON_T2CON_bit := 0;                // OFF
  TCKPS_0_T2CON_bit := 0;            // 00 = 1; 01 = 8; 10 = 64; 11 = 256
  TCKPS_1_T2CON_bit := 0;
  IPC2 := IPC2 or 0x1000;            // interrupt priority level = 1
  PR2 := 0;
  PR3 := 0;
  TMR3HLD := 0;
  TMR2 := 0;
  // Upper Timer fires the interrupts
  T3IF_bit := 0;                     // clear T1IF
  T3IE_bit := 1;                     // enable Timer1 interrupts
  // Lower Timer controls the setup Setup
  TON_T2CON_bit := 1;                // ON
  
  // Lower Timer controls the setup Setup
  T32_T4CON_bit := 1;                // 32 Bit mode
  TON_T4CON_bit := 0;                // OFF
  TCKPS_0_T4CON_bit := 0;            // 00 = 1; 01 = 8; 10 = 64; 11 = 256
  TCKPS_1_T4CON_bit := 0;
  IPC7 := IPC7 or 0x1000;            // interrupt priority level = 1
  PR4 := LoWord(MAX_DWELL_COUNT);
  PR5 := HiWord(MAX_DWELL_COUNT);
  TMR5HLD := 0;
  TMR4 := 0;
  // Upper Timer fires the interrupts
  T5IF_bit := 0;                     // clear T1IF
  T5IE_bit := 1;                     // enable Timer1 interrupts
  // Lower Timer controls the setup Setup
  TON_T4CON_bit := 1;                // ON

  // Initializze Variables
  RPM := 0.0;
  CylinderFiringPeriod := 0.0;
  Max_Dwell_Exceeded := True;               // Start Safe

  while true do
  begin
    UART1_Init(9600);
    if UART_Data_Ready > 0 then
    begin
      UART_Read;
    end;
    LATB14_bit := not LATB14_bit;  // Heartbeat
    LATB7_bit := not LATB7_bit;
    // Waitin for Pin Change Interrupt
  end;
end.